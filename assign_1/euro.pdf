%PDF-1.4
%“Œ‹ž ReportLab Generated PDF document http://www.reportlab.com
1 0 obj
<< /F1 2 0 R /F2 3 0 R /F3 4 0 R /F4 5 0 R /F5 11 0 R /F6 12 0 R 
  /F7 19 0 R >>
endobj
2 0 obj
<< /BaseFont /Helvetica /Encoding /WinAnsiEncoding /Name /F1 /Subtype /Type1 /Type /Font >>
endobj
3 0 obj
<< /BaseFont /Helvetica-Bold /Encoding /WinAnsiEncoding /Name /F2 /Subtype /Type1 /Type /Font >>
endobj
4 0 obj
<< /BaseFont /Helvetica-Oblique /Encoding /WinAnsiEncoding /Name /F3 /Subtype /Type1 /Type /Font >>
endobj
5 0 obj
<< /BaseFont /Courier /Encoding /WinAnsiEncoding /Name /F4 /Subtype /Type1 /Type /Font >>
endobj
6 0 obj
<< /A << /S /URI /Type /Action /URI (http://en.wikipedia.org/wiki/Euro_banknotes#Serial_number) >> /Border [ 0 0 0 ] /Rect [ 304.1557 542.7736 376.4057 554.7736 ] /Subtype /Link /Type /Annot >>
endobj
7 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 27 0 R /XYZ 68.69291 243.9843 0 ] /Rect [ 380.5336 542.7736 388.5534 554.7736 ] /Subtype /Link /Type /Annot >>
endobj
8 0 obj
<< /A << /S /URI /Type /Action /URI (http://en.wikipedia.org/wiki/Euro_banknotes#Serial_number) >> /Border [ 0 0 0 ] /Rect [ 108.2132 434.7736 180.4632 446.7736 ] /Subtype /Link /Type /Annot >>
endobj
9 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 27 0 R /XYZ 68.69291 243.9843 0 ] /Rect [ 184.0483 434.7736 191.5255 446.7736 ] /Subtype /Link /Type /Annot >>
endobj
10 0 obj
<< /Annots [ 6 0 R 7 0 R 8 0 R 9 0 R ] /Contents 40 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 39 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 
  /Trans <<  >> /Type /Page >>
endobj
11 0 obj
<< /BaseFont /Courier-Oblique /Encoding /WinAnsiEncoding /Name /F5 /Subtype /Type1 /Type /Font >>
endobj
12 0 obj
<< /BaseFont /Courier-Bold /Encoding /WinAnsiEncoding /Name /F6 /Subtype /Type1 /Type /Font >>
endobj
13 0 obj
<< /A << /S /URI /Type /Action /URI (http://en.wikipedia.org/wiki/C_data_types) >> /Border [ 0 0 0 ] /Rect [ 303.7533 124.1736 360.9714 136.1736 ] /Subtype /Link /Type /Annot >>
endobj
14 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 27 0 R /XYZ 68.69291 231.9843 0 ] /Rect [ 364.2904 124.1736 368.7384 136.1736 ] /Subtype /Link /Type /Annot >>
endobj
15 0 obj
<< /Annots [ 13 0 R 14 0 R ] /Contents 41 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 39 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 
  /Trans <<  >> /Type /Page >>
endobj
16 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 27 0 R /XYZ 68.69291 255.9843 0 ] /Rect [ 273.0496 711.7736 277.4976 723.7736 ] /Subtype /Link /Type /Annot >>
endobj
17 0 obj
<< /A << /S /URI /Type /Action /URI (http://en.wikipedia.org/wiki/Euro_banknotes#Serial_number) >> /Border [ 0 0 0 ] /Rect [ 62.69291 561.7736 134.9429 573.7736 ] /Subtype /Link /Type /Annot >>
endobj
18 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 27 0 R /XYZ 68.69291 243.9843 0 ] /Rect [ 137.7229 561.7736 142.1709 573.7736 ] /Subtype /Link /Type /Annot >>
endobj
19 0 obj
<< /BaseFont /Helvetica-BoldOblique /Encoding /WinAnsiEncoding /Name /F7 /Subtype /Type1 /Type /Font >>
endobj
20 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 27 0 R /XYZ 264.6629 725.0236 0 ] /Rect [ 68.69291 242.7343 74.25291 254.7343 ] /Subtype /Link /Type /Annot >>
endobj
21 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 10 0 R /XYZ 368.4029 556.0236 0 ] /Rect [ 77.58291 230.7343 83.14291 242.7343 ] /Subtype /Link /Type /Annot >>
endobj
22 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 10 0 R /XYZ 181.6329 448.0236 0 ] /Rect [ 88.70291 230.7343 94.26291 242.7343 ] /Subtype /Link /Type /Annot >>
endobj
23 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 27 0 R /XYZ 137.7229 575.0236 0 ] /Rect [ 99.82291 230.7343 105.3829 242.7343 ] /Subtype /Link /Type /Annot >>
endobj
24 0 obj
<< /A << /S /URI /Type /Action /URI (http://en.wikipedia.org/wiki/Euro_banknotes#Serial_number) >> /Border [ 0 0 0 ] /Rect [ 153.7323 230.7343 532.5827 242.7343 ] /Subtype /Link /Type /Annot >>
endobj
25 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 15 0 R /XYZ 357.2829 137.4236 0 ] /Rect [ 68.69291 218.7343 74.25291 230.7343 ] /Subtype /Link /Type /Annot >>
endobj
26 0 obj
<< /A << /S /URI /Type /Action /URI (http://en.wikipedia.org/wiki/C_data_types) >> /Border [ 0 0 0 ] /Rect [ 153.7323 218.7343 532.5827 230.7343 ] /Subtype /Link /Type /Annot >>
endobj
27 0 obj
<< /Annots [ 16 0 R 17 0 R 18 0 R 20 0 R 21 0 R 22 0 R 23 0 R 24 0 R 25 0 R 26 0 R ] /Contents 42 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 39 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 
  /Trans <<  >> /Type /Page >>
endobj
28 0 obj
<< /Outlines 30 0 R /PageLabels 43 0 R /PageMode /UseNone /Pages 39 0 R /Type /Catalog >>
endobj
29 0 obj
<< /Author () /CreationDate (D:20150201184503-01'00') /Creator (\(unspecified\)) /Keywords () /Producer (ReportLab PDF Library - www.reportlab.com) /Subject (\(unspecified\)) 
  /Title (Programming in C) >>
endobj
30 0 obj
<< /Count 10 /First 31 0 R /Last 31 0 R /Type /Outlines >>
endobj
31 0 obj
<< /Count 7 /Dest [ 10 0 R /XYZ 62.69291 707.0236 0 ] /First 32 0 R /Last 36 0 R /Parent 30 0 R /Title (Assignment 1: Serial numbers) >>
endobj
32 0 obj
<< /Dest [ 10 0 R /XYZ 62.69291 518.0236 0 ] /Next 33 0 R /Parent 31 0 R /Title (First method) >>
endobj
33 0 obj
<< /Dest [ 10 0 R /XYZ 62.69291 226.4236 0 ] /Next 34 0 R /Parent 31 0 R /Prev 32 0 R /Title (Second method) >>
endobj
34 0 obj
<< /Dest [ 15 0 R /XYZ 62.69291 695.8236 0 ] /Next 35 0 R /Parent 31 0 R /Prev 33 0 R /Title (Assignment) >>
endobj
35 0 obj
<< /Dest [ 15 0 R /XYZ 62.69291 440.6236 0 ] /Next 36 0 R /Parent 31 0 R /Prev 34 0 R /Title (Implementation tips) >>
endobj
36 0 obj
<< /Count 2 /Dest [ 27 0 R /XYZ 62.69291 507.0236 0 ] /First 37 0 R /Last 38 0 R /Parent 31 0 R /Prev 35 0 R 
  /Title (Bonus assignments) >>
endobj
37 0 obj
<< /Dest [ 27 0 R /XYZ 62.69291 477.0236 0 ] /Next 38 0 R /Parent 36 0 R /Title (Europa Series) >>
endobj
38 0 obj
<< /Dest [ 27 0 R /XYZ 62.69291 396.0236 0 ] /Parent 36 0 R /Prev 37 0 R /Title (Generating serial numbers) >>
endobj
39 0 obj
<< /Count 3 /Kids [ 10 0 R 15 0 R 27 0 R ] /Type /Pages >>
endobj
40 0 obj
<< /Length 5604 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 741.0236 cm
q
BT 1 0 0 1 0 4 Tm 148.2649 0 Td 24 TL /F2 20 Tf 0 0 0 rg (Programming in C) Tj T* -148.2649 0 Td ET
Q
Q
q
1 0 0 1 62.69291 719.0236 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 0 rg (Deadline: ) Tj /F3 10 Tf 0 0 0 rg (6 February, 23:59) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 686.0236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F2 17.5 Tf 0 0 0 rg (Assignment 1: Serial numbers) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 632.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 38 Tm /F1 10 Tf 12 TL .651988 Tw (A friend of yours owns a small business and his customers often pay him in cash. He is worried that the) Tj T* 0 Tw 1.842927 Tw (banknotes he receives might be counterfeit, so he asks if you can help detect the fakes. After some) Tj T* 0 Tw 2.55061 Tw (research you discover that in addition to the visual security features you can also check the serial) Tj T* 0 Tw (numbers of the euro banknotes.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 530.0236 cm
q
BT 1 0 0 1 0 86 Tm .01186 Tw 12 TL /F1 10 Tf 0 0 0 rg (The first series of Euro banknotes was introduced in 2002. In 2012 the European Central Bank announced) Tj T* 0 Tw .845542 Tw (that these will be replaced with the second series, called the Europa series. Since 2013 the new 5 euro) Tj T* 0 Tw 1.36686 Tw (and 10 euro banknotes from the Europa series have entered circulation. Both the first and the second) Tj T* 0 Tw .962339 Tw (series have a unique serial number. The validity of the serial number can be checked in different ways.) Tj T* 0 Tw .428488 Tw (The format of the serial number on the first series of banknotes is a single letter followed by 11 digits. An) Tj T* 0 Tw 1.421235 Tw (example of a valid serial number from the first series of euro banknotes is ) Tj /F4 10 Tf 0 0 0 rg (X55266826871) Tj /F1 10 Tf 0 0 0 rg (. The letter) Tj T* 0 Tw 1.347851 Tw (indicates the country that issued the banknote. This ) Tj 0 0 .501961 rg (checksum_table) Tj 0 0 0 rg ( ) Tj /F1 8 Tf 0 0 .501961 rg 5 Ts (2 ) Tj /F1 10 Tf 0 0 0 rg 0 Ts (maps letters to the country that) Tj T* 0 Tw (issued the banknote. In this case, the 'X' indicates that our banknote was issued in Germany.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 500.0236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F2 15 Tf 0 0 0 rg (First method) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 422.0236 cm
q
BT 1 0 0 1 0 62 Tm 1.944724 Tw 12 TL /F1 10 Tf 0 0 0 rg (To check the validity of a serial number, we first split the letter from the numerical part of the serial) Tj T* 0 Tw 1.803876 Tw (number. This gives us the pair \(X, 55266826871\). The serial number is valid if the digital root of the) Tj T* 0 Tw 2.503984 Tw (numerical part matches the checksum digit associated with the country code 'X'. The digital root is) Tj T* 0 Tw 1.423984 Tw (calculated by repeatedly summing the individual digits of the number until the result becomes a single) Tj T* 0 Tw .805145 Tw (digit. The ) Tj 0 0 .501961 rg (checksum_table) Tj 0 0 0 rg ( ) Tj /F1 8 Tf 0 0 .501961 rg 5 Ts (2 ) Tj /F1 10 Tf 0 0 0 rg 0 Ts (shows that the checksum digit of 'X' is 2. To calculate the digital root of the) Tj T* 0 Tw (number 55266826871, we start by calculating the digit sum of 55266826871:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 388.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 24 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F4 10 Tf 12 TL (5+5+2+6+6+8+2+6+8+7+1 = 56) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 368.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (The digit sum of 56 is:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 335.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 24 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F4 10 Tf 12 TL (5+6 = 11) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 315.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (And finally we find the digital root:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 282.4236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 24 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F4 10 Tf 12 TL (1 + 1 = 2) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 238.4236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL 1.516457 Tw (The digital root of 55266826871 is 2 which matches the checksum digit in the reference table, so our) Tj T* 0 Tw .217356 Tw (serial number is indeed valid. We urge you to think about how you would implement this. Can you think of) Tj T* 0 Tw (an efficient way to calculate a digital sum?) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 208.4236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F2 15 Tf 0 0 0 rg (Second method) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 166.4236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL .292093 Tw (A second way to check the serial number is to convert the country code character to it's ASCII value. The) Tj T* 0 Tw .843988 Tw (sum of digits of the number part plus the ASCII value of the country code should then be divisible by 9.) Tj T* 0 Tw (The digit sum of 55266826871 is \(still\):) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 133.2236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 24 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F4 10 Tf 12 TL (5+5+2+6+6+8+2+6+8+7+1 = 56) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 113.2236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (The ASCII value of 'X' is 88, so:) Tj T* ET
Q
Q
 
endstream
endobj
41 0 obj
<< /Length 10534 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 727.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 36 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F4 10 Tf 12 TL (56 + 88 = 144) Tj T* (144 % 9 = 0) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 707.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Therefore, our serial number is also correct according to the second method.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 677.8236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F2 15 Tf 0 0 0 rg (Assignment) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 647.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL .373516 Tw (Your assignment is to implement these two methods to check the serial numbers of banknotes of the first) Tj T* 0 Tw (series.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 569.8236 cm
q
BT 1 0 0 1 0 62 Tm .779985 Tw 12 TL /F1 10 Tf 0 0 0 rg (Your program should read the serial numbers from standard input, one serial number per line. To check) Tj T* 0 Tw 4.43436 Tw (your program you can use the banknotes in your wallet or use the ) Tj /F4 10 Tf 0 0 0 rg (serial.txt ) Tj /F1 10 Tf 0 0 0 rg (file in the) Tj T* 0 Tw .429318 Tw /F4 10 Tf 0 0 0 rg (template_code ) Tj /F1 10 Tf 0 0 0 rg (directory. The first five serial numbers in ) Tj /F4 10 Tf 0 0 0 rg (serials.txt ) Tj /F1 10 Tf 0 0 0 rg (are valid, and the last two are) Tj T* 0 Tw 1.409398 Tw (invalid. Your program should print the serial number followed by ) Tj /F4 10 Tf 0 0 0 rg (OK ) Tj /F1 10 Tf 0 0 0 rg (if the serial number is correct, or) Tj T* 0 Tw .089461 Tw /F4 10 Tf 0 0 0 rg (FAILED ) Tj /F1 10 Tf 0 0 0 rg (if the serial number fails one or both of the tests. With ) Tj /F4 10 Tf 0 0 0 rg (serials.txt ) Tj /F1 10 Tf 0 0 0 rg (as input, the output of your) Tj T* 0 Tw (program should be:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 452.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 108 re B*
Q
q
BT 1 0 0 1 0 86 Tm 12 TL /F4 10 Tf 0 0 0 rg ($ ./checksum ) Tj (<) Tj ( serials.txt) Tj T* (X55266826871: OK) Tj T* (U77882681066: OK) Tj T* (Z74542963239: OK) Tj T* (L40424180045: OK) Tj T* (L25388047085: OK) Tj T* (A25388047085: FAILED) Tj T* (L25388049086: FAILED) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 422.6236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F2 15 Tf 0 0 0 rg (Implementation tips) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 380.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL 1.484692 Tw (C is low level language and reading data is more complicated than in higher level languages such as) Tj T* 0 Tw .536457 Tw (Python or Java. To help you along with your first assignment we have provided some template code that) Tj T* 0 Tw (reads the serial numbers from standard input. The main loop is:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 167.4236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 204 re B*
Q
q
.960784 .960784 .862745 rg
n 0 180.75 18 12 re f*
.960784 .960784 .862745 rg
n 24 180.75 24 12 re f*
.960784 .960784 .862745 rg
n 48 180.75 6 12 re f*
.960784 .960784 .862745 rg
n 54 180.75 24 12 re f*
.960784 .960784 .862745 rg
n 78 180.75 6 12 re f*
.960784 .960784 .862745 rg
n 90 180.75 6 12 re f*
.960784 .960784 .862745 rg
n 24 168.75 24 12 re f*
.960784 .960784 .862745 rg
n 54 168.75 24 12 re f*
.960784 .960784 .862745 rg
n 84 168.75 18 12 re f*
.960784 .960784 .862745 rg
n 102 168.75 6 12 re f*
.960784 .960784 .862745 rg
n 114 168.75 330 12 re f*
.960784 .960784 .862745 rg
n 24 156.75 24 12 re f*
.960784 .960784 .862745 rg
n 54 156.75 6 12 re f*
.960784 .960784 .862745 rg
n 60 156.75 6 12 re f*
.960784 .960784 .862745 rg
n 24 132.75 30 12 re f*
.960784 .960784 .862745 rg
n 60 132.75 6 12 re f*
.960784 .960784 .862745 rg
n 66 132.75 36 12 re f*
.960784 .960784 .862745 rg
n 102 132.75 6 12 re f*
.960784 .960784 .862745 rg
n 108 132.75 30 12 re f*
.960784 .960784 .862745 rg
n 138 132.75 6 12 re f*
.960784 .960784 .862745 rg
n 150 132.75 42 12 re f*
.960784 .960784 .862745 rg
n 192 132.75 12 12 re f*
.960784 .960784 .862745 rg
n 204 132.75 6 12 re f*
.960784 .960784 .862745 rg
n 210 132.75 6 12 re f*
.960784 .960784 .862745 rg
n 222 132.75 6 12 re f*
.960784 .960784 .862745 rg
n 228 132.75 6 12 re f*
.960784 .960784 .862745 rg
n 234 132.75 6 12 re f*
.960784 .960784 .862745 rg
n 246 132.75 6 12 re f*
.960784 .960784 .862745 rg
n 252 132.75 18 12 re f*
.960784 .960784 .862745 rg
n 270 132.75 6 12 re f*
.960784 .960784 .862745 rg
n 282 132.75 12 12 re f*
.960784 .960784 .862745 rg
n 300 132.75 6 12 re f*
.960784 .960784 .862745 rg
n 306 132.75 6 12 re f*
.960784 .960784 .862745 rg
n 318 132.75 6 12 re f*
.960784 .960784 .862745 rg
n 48 120.75 36 12 re f*
.960784 .960784 .862745 rg
n 84 120.75 6 12 re f*
.960784 .960784 .862745 rg
n 90 120.75 60 12 re f*
.960784 .960784 .862745 rg
n 150 120.75 6 12 re f*
.960784 .960784 .862745 rg
n 162 120.75 6 12 re f*
.960784 .960784 .862745 rg
n 168 120.75 6 12 re f*
.960784 .960784 .862745 rg
n 180 120.75 18 12 re f*
.960784 .960784 .862745 rg
n 198 120.75 12 12 re f*
.960784 .960784 .862745 rg
n 48 96.75 12 12 re f*
.960784 .960784 .862745 rg
n 66 96.75 6 12 re f*
.960784 .960784 .862745 rg
n 72 96.75 72 12 re f*
.960784 .960784 .862745 rg
n 144 96.75 6 12 re f*
.960784 .960784 .862745 rg
n 150 96.75 6 12 re f*
.960784 .960784 .862745 rg
n 156 96.75 6 12 re f*
.960784 .960784 .862745 rg
n 168 96.75 18 12 re f*
.960784 .960784 .862745 rg
n 186 96.75 12 12 re f*
.960784 .960784 .862745 rg
n 204 96.75 6 12 re f*
.960784 .960784 .862745 rg
n 72 84.75 36 12 re f*
.960784 .960784 .862745 rg
n 108 84.75 6 12 re f*
.960784 .960784 .862745 rg
n 114 84.75 24 12 re f*
.960784 .960784 .862745 rg
n 138 84.75 12 12 re f*
.960784 .960784 .862745 rg
n 48 72.75 6 12 re f*
.960784 .960784 .862745 rg
n 60 72.75 24 12 re f*
.960784 .960784 .862745 rg
n 90 72.75 6 12 re f*
.960784 .960784 .862745 rg
n 72 60.75 36 12 re f*
.960784 .960784 .862745 rg
n 108 60.75 6 12 re f*
.960784 .960784 .862745 rg
n 114 60.75 48 12 re f*
.960784 .960784 .862745 rg
n 162 60.75 12 12 re f*
.960784 .960784 .862745 rg
n 48 48.75 6 12 re f*
.960784 .960784 .862745 rg
n 48 36.75 36 12 re f*
.960784 .960784 .862745 rg
n 84 36.75 6 12 re f*
.960784 .960784 .862745 rg
n 90 36.75 6 12 re f*
.960784 .960784 .862745 rg
n 96 36.75 12 12 re f*
.960784 .960784 .862745 rg
n 108 36.75 6 12 re f*
.960784 .960784 .862745 rg
n 114 36.75 12 12 re f*
.960784 .960784 .862745 rg
n 24 24.75 6 12 re f*
.960784 .960784 .862745 rg
n 24 12.75 36 12 re f*
.960784 .960784 .862745 rg
n 66 12.75 72 12 re f*
.960784 .960784 .862745 rg
n 138 12.75 6 12 re f*
.960784 .960784 .862745 rg
n 0 .75 6 12 re f*
BT 1 0 0 1 0 182 Tm 12 TL /F4 10 Tf .690196 0 .25098 rg (int) Tj 0 0 0 rg ( ) Tj 0 0 1 rg (main) Tj 0 0 0 rg (\() Tj .690196 0 .25098 rg (void) Tj 0 0 0 rg (\)) Tj 0 0 0 rg ( ) Tj 0 0 0 rg ({) Tj 0 0 0 rg  T* (    ) Tj .690196 0 .25098 rg (long) Tj 0 0 0 rg ( ) Tj .690196 0 .25098 rg (long) Tj 0 0 0 rg ( ) Tj 0 0 0 rg (num) Tj 0 0 0 rg (;) Tj 0 0 0 rg ( ) Tj /F5 10 Tf .25098 .501961 .501961 rg (// Need 64 bit integer to store 11 digit serial number.) Tj T* /F4 10 Tf 0 0 0 rg (    ) Tj .690196 0 .25098 rg (char) Tj 0 0 0 rg ( ) Tj 0 0 0 rg (c) Tj 0 0 0 rg (;) Tj 0 0 0 rg  T*  T* (    ) Tj /F6 10 Tf 0 .501961 0 rg (while) Tj /F4 10 Tf 0 0 0 rg ( ) Tj 0 0 0 rg (\() Tj 0 0 0 rg (fscanf) Tj 0 0 0 rg (\() Tj 0 0 0 rg (stdin) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( ) Tj .729412 .129412 .129412 rg ("%c%lld) Tj /F6 10 Tf .733333 .4 .133333 rg (\\n) Tj /F4 10 Tf .729412 .129412 .129412 rg (") Tj 0 0 0 rg (,) Tj 0 0 0 rg ( ) Tj .4 .4 .4 rg (&) Tj 0 0 0 rg (c) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( ) Tj .4 .4 .4 rg (&) Tj 0 0 0 rg (num) Tj 0 0 0 rg (\)) Tj 0 0 0 rg ( ) Tj .4 .4 .4 rg (==) Tj 0 0 0 rg ( ) Tj .4 .4 .4 rg (2) Tj 0 0 0 rg (\)) Tj 0 0 0 rg ( ) Tj 0 0 0 rg ({) Tj 0 0 0 rg  T* (        ) Tj 0 0 0 rg (printf) Tj 0 0 0 rg (\() Tj .729412 .129412 .129412 rg ("%c%lld: ") Tj 0 0 0 rg (,) Tj 0 0 0 rg ( ) Tj 0 0 0 rg (c) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( ) Tj 0 0 0 rg (num) Tj 0 0 0 rg (\);) Tj 0 0 0 rg  T*  T* (        ) Tj /F6 10 Tf 0 .501961 0 rg (if) Tj /F4 10 Tf 0 0 0 rg ( ) Tj 0 0 0 rg (\() Tj 0 0 0 rg (check_serial) Tj 0 0 0 rg (\() Tj 0 0 0 rg (c) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( ) Tj 0 0 0 rg (num) Tj 0 0 0 rg (\)\)) Tj 0 0 0 rg ( ) Tj 0 0 0 rg ({) Tj 0 0 0 rg  T* (            ) Tj 0 0 0 rg (printf) Tj 0 0 0 rg (\() Tj .729412 .129412 .129412 rg ("OK") Tj 0 0 0 rg (\);) Tj 0 0 0 rg  T* (        ) Tj 0 0 0 rg (}) Tj 0 0 0 rg ( ) Tj /F6 10 Tf 0 .501961 0 rg (else) Tj /F4 10 Tf 0 0 0 rg ( ) Tj 0 0 0 rg ({) Tj 0 0 0 rg  T* (            ) Tj 0 0 0 rg (printf) Tj 0 0 0 rg (\() Tj .729412 .129412 .129412 rg ("FAILED") Tj 0 0 0 rg (\);) Tj 0 0 0 rg  T* (        ) Tj 0 0 0 rg (}) Tj 0 0 0 rg  T* (        ) Tj 0 0 0 rg (printf) Tj 0 0 0 rg (\() Tj .729412 .129412 .129412 rg (") Tj /F6 10 Tf .733333 .4 .133333 rg (\\n) Tj /F4 10 Tf .729412 .129412 .129412 rg (") Tj 0 0 0 rg (\);) Tj 0 0 0 rg  T* (    ) Tj 0 0 0 rg (}) Tj 0 0 0 rg  T* (    ) Tj /F6 10 Tf 0 .501961 0 rg (return) Tj /F4 10 Tf 0 0 0 rg ( ) Tj 0 0 0 rg (EXIT_SUCCESS) Tj 0 0 0 rg (;) Tj 0 0 0 rg  T* 0 0 0 rg (}) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 99.42362 cm
q
BT 1 0 0 1 0 50 Tm .724751 Tw 12 TL /F1 10 Tf 0 0 0 rg (You can find the rest of the code in ) Tj /F4 10 Tf 0 0 0 rg (checksum.c) Tj /F1 10 Tf 0 0 0 rg (. The first thing to notice is that the number part of the ) Tj T* 0 Tw .031807 Tw (serial number is an 11 digit number that will not fit in the C ) Tj /F4 10 Tf 0 0 0 rg (int ) Tj /F1 10 Tf 0 0 0 rg (or ) Tj /F4 10 Tf 0 0 0 rg (long ) Tj /F1 10 Tf 0 0 0 rg (type. So the code uses the``long ) Tj T* 0 Tw .53904 Tw (long`` integer type which is guaranteed to be 64 bits \() Tj 0 0 .501961 rg (C data types) Tj 0 0 0 rg ( ) Tj /F1 8 Tf 0 0 .501961 rg 5 Ts (3) Tj /F1 10 Tf 0 0 0 rg 0 Ts (\). This might seem confusing at first, ) Tj T* 0 Tw .767633 Tw (but remember that C can be compiled for a myriad of architectures. While your computer might have 32 ) Tj T* 0 Tw 1.056654 Tw (bit integers, the ) Tj /F4 10 Tf 0 0 0 rg (int ) Tj /F1 10 Tf 0 0 0 rg (type only guarantees 16 bits in the C standard. The ) Tj /F4 10 Tf 0 0 0 rg (long ) Tj /F1 10 Tf 0 0 0 rg (type, which you might) Tj T* 0 Tw ET
Q
Q
 
endstream
endobj
42 0 obj
<< /Length 5902 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 741.0236 cm
q
BT 1 0 0 1 0 14 Tm .564751 Tw 12 TL /F1 10 Tf 0 0 0 rg (expect to be 64 bits in size, is only guaranteed to be 32 bits! You might want to think about the following) Tj T* 0 Tw (problem: if you want to store a decimal number with eleven digits in binary, how many bits do you need?) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 603.0236 cm
q
BT 1 0 0 1 0 122 Tm .035703 Tw 12 TL /F1 10 Tf 0 0 0 rg (The serial numbers of the bank notes have a fixed format, and if you know the format of the input data you) Tj T* 0 Tw 1.048339 Tw (should use a function of the ) Tj /F4 10 Tf 0 0 0 rg (scanf\(\) ) Tj /F1 10 Tf 0 0 0 rg (family ) Tj /F1 8 Tf 0 0 .501961 rg 5 Ts (1) Tj /F1 10 Tf 0 0 0 rg 0 Ts (. Since you are reading from a file \(remember, standard) Tj T* 0 Tw .124987 Tw (input in C is nothing more than a glorified file pointer\) you use ) Tj /F4 10 Tf 0 0 0 rg (fscanf\(\)) Tj /F1 10 Tf 0 0 0 rg (, which has three arguments: the) Tj T* 0 Tw .713145 Tw (file descriptor to read from, a format string that specifies the types of the data elements to read, and the) Tj T* 0 Tw 1.237356 Tw (locations to store the data that is read. Because the scan function needs to store the data we need to) Tj T* 0 Tw .680574 Tw (pass the locations of the variables instead of the variables themselves. This is done with the ) Tj /F4 10 Tf 0 0 0 rg (& ) Tj /F1 10 Tf 0 0 0 rg (operator) Tj T* 0 Tw .379513 Tw (and will be explained later on in the lectures. For now you can just use the code and expect the data that) Tj T* 0 Tw 1.224198 Tw (is read to appear in the variables ) Tj /F4 10 Tf 0 0 0 rg (c ) Tj /F1 10 Tf 0 0 0 rg (and ) Tj /F4 10 Tf 0 0 0 rg (num) Tj /F1 10 Tf 0 0 0 rg (. The return value of ) Tj /F4 10 Tf 0 0 0 rg (fscanf ) Tj /F1 10 Tf 0 0 0 rg (is the number of elements) Tj T* 0 Tw 3.870574 Tw (read, so the loop ends when there are no more serial number to read. The template code in) Tj T* 0 Tw .08686 Tw /F4 10 Tf 0 0 0 rg (checksum.c ) Tj /F1 10 Tf 0 0 0 rg (lacks the actual checksum tests and will always accept the serial numbers that it reads. You) Tj T* 0 Tw (can type ) Tj /F4 10 Tf 0 0 0 rg (make) Tj ( ) Tj (check ) Tj /F1 10 Tf 0 0 0 rg (to run the program with ) Tj /F4 10 Tf 0 0 0 rg (serials.txt ) Tj /F1 10 Tf 0 0 0 rg (as input.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 561.0236 cm
q
BT 1 0 0 1 0 26 Tm .629431 Tw 12 TL /F1 10 Tf 0 0 0 rg (You will also need a function that takes a country code character and returns the checksum digit for that) Tj T* 0 Tw 1.223145 Tw (country. For this can use a ) Tj /F4 10 Tf 0 0 0 rg (switch ) Tj /F1 10 Tf 0 0 0 rg (statement or a lookup in an array that contains the data from the) Tj T* 0 Tw 0 0 .501961 rg (checksum_table) Tj 0 0 0 rg ( ) Tj /F1 8 Tf 0 0 .501961 rg 5 Ts (2) Tj /F1 10 Tf 0 0 0 rg 0 Ts (.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 519.0236 cm
q
BT 1 0 0 1 0 26 Tm .075542 Tw 12 TL /F1 10 Tf 0 0 0 rg (You are of course free to ignore this code completely and write your own program from scratch. You could) Tj T* 0 Tw .056654 Tw (for example consider using ) Tj /F4 10 Tf 0 0 0 rg (getchar) Tj /F1 10 Tf 0 0 0 rg (. Either way we encourage you to read up on the details of the library) Tj T* 0 Tw (functions you use in the manual pages. For more information about the manual system type: ) Tj /F4 10 Tf 0 0 0 rg (man) Tj ( ) Tj (man) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 489.0236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F2 15 Tf 0 0 0 rg (Bonus assignments) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 462.0236 cm
q
BT 1 0 0 1 0 2.5 Tm 15 TL /F7 12.5 Tf 0 0 0 rg (Europa Series) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 408.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 38 Tm /F1 10 Tf 12 TL .361235 Tw (Implement the same checks for the Europa series of banknotes. The serial number of the new banknotes) Tj T* 0 Tw .977882 Tw (has a different format: Two letters followed by 10 digits. The first letter is still the country code, and the) Tj T* 0 Tw .039988 Tw (second letter can be seen as an extended digit. When you calculate the digit sum of the serial number you) Tj T* 0 Tw (can just use the ASCII value of the second letter.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 381.0236 cm
q
BT 1 0 0 1 0 2.5 Tm 15 TL /F7 12.5 Tf 0 0 0 rg (Generating serial numbers) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 339.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL .977882 Tw (Checking serial numbers is useful, but it is of course more fun to find an efficient way to generate valid) Tj T* 0 Tw .46936 Tw (serial numbers. As a bonus exercise write a program that will efficiently generate valid serial numbers for) Tj T* 0 Tw (a given country code.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 282.3307 cm
Q
q
1 0 0 1 62.69291 253.9843 cm
n 0 14.17323 m 469.8898 14.17323 l S
Q
q
1 0 0 1 62.69291 241.9843 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 0 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 .501961 rg (1) Tj T* ET
Q
Q
q
1 0 0 1 91.03937 0 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 0 rg (They are called scan) Tj /F2 10 Tf (f) Tj /F1 10 Tf (\(\) for a reason you know.) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 229.9843 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 0 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 0 rg (2\() Tj 0 0 .501961 rg (1) Tj 0 0 0 rg (, ) Tj 0 0 .501961 rg (2) Tj 0 0 0 rg (, ) Tj 0 0 .501961 rg (3) Tj 0 0 0 rg (\)) Tj T* ET
Q
Q
q
1 0 0 1 91.03937 0 cm
q
0 0 .501961 rg
0 0 .501961 RG
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (http://en.wikipedia.org/wiki/Euro_banknotes#Serial_number) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 217.9843 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 0 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 .501961 rg (3) Tj T* ET
Q
Q
q
1 0 0 1 91.03937 0 cm
q
0 0 .501961 rg
0 0 .501961 RG
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (http://en.wikipedia.org/wiki/C_data_types) Tj T* ET
Q
Q
q
Q
Q
 
endstream
endobj
43 0 obj
<< /Nums [ 0 44 0 R 1 45 0 R 2 46 0 R ] >>
endobj
44 0 obj
<< /S /D /St 1 >>
endobj
45 0 obj
<< /S /D /St 2 >>
endobj
46 0 obj
<< /S /D /St 3 >>
endobj
xref
0 47
0000000000 65535 f
0000000075 00000 n
0000000176 00000 n
0000000286 00000 n
0000000401 00000 n
0000000519 00000 n
0000000627 00000 n
0000000839 00000 n
0000001010 00000 n
0000001222 00000 n
0000001393 00000 n
0000001639 00000 n
0000001756 00000 n
0000001870 00000 n
0000002067 00000 n
0000002239 00000 n
0000002475 00000 n
0000002647 00000 n
0000002860 00000 n
0000003032 00000 n
0000003155 00000 n
0000003327 00000 n
0000003499 00000 n
0000003671 00000 n
0000003843 00000 n
0000004056 00000 n
0000004228 00000 n
0000004425 00000 n
0000004717 00000 n
0000004826 00000 n
0000005053 00000 n
0000005131 00000 n
0000005287 00000 n
0000005404 00000 n
0000005535 00000 n
0000005663 00000 n
0000005800 00000 n
0000005962 00000 n
0000006080 00000 n
0000006210 00000 n
0000006288 00000 n
0000011949 00000 n
0000022541 00000 n
0000028500 00000 n
0000028562 00000 n
0000028599 00000 n
0000028636 00000 n
trailer
<< /ID 
 % ReportLab generated PDF document -- digest (http://www.reportlab.com)
 [(\234p\331\375\364\267\331\361\025'\012r\2431\344O) (\234p\331\375\364\267\331\361\025'\012r\2431\344O)]
 /Info 29 0 R /Root 28 0 R /Size 47 >>
startxref
28673
%%EOF
